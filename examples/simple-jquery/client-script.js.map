{"version":3,"file":"client-script.js","names":["serialized: Record<string, unknown | StoredMedia>","record: CacheRecord","createStore: () => Store","store","body: string | undefined","data: string | Record<string, unknown>","data: string | Record<string, unknown>"],"sources":["../../src/utils.ts","../../src/store/LocalStore.ts","../../src/store/index.ts","../../src/override/fetch.ts","../../src/override/xhr.ts","../../src/ui/hud.ts","../../src/client-script.ts"],"sourcesContent":["import { StoredMedia } from './types'\n\n/**\n * Encode URL to safe filename using browser-compatible base64 encoding\n * Uses URL-safe base64 variant: / -> _ and + -> - , removes padding =\n */\nexport function urlToFilename(url: string): string {\n  const base64 = btoa(url)\n    .replace(/\\//g, '_')\n    .replace(/\\+/g, '-')\n    .replace(/=/g, '')\n  return base64 + '.json'\n}\n\n/**\n * Decode filename back to URL using browser-compatible base64 decoding\n * Reverses URL-safe base64: _ -> / and - -> + , restores padding\n */\nexport function filenameToUrl(filename: string): string {\n  // Remove .json extension\n  let base64 = filename.replace('.json', '')\n\n  // Restore base64 characters\n  base64 = base64.replace(/_/g, '/').replace(/-/g, '+')\n\n  // Restore padding\n  const paddingNeeded = (4 - (base64.length % 4)) % 4\n  base64 = base64 + '='.repeat(paddingNeeded)\n\n  return atob(base64)\n}\n\nexport const isMedia = (url: URL) => {\n  return /\\.(jpe?g|png|gif|svg|webp|ico|mp4|mp3|woff2?|ttf|css|js)$/i.test(url.pathname)\n}\n\nexport const isApi = (url: URL) => {\n  return url.pathname.includes('/api/__')\n}\n\nexport const getURL = (input: string | URL | Request): URL | null => {\n  try {\n    if (typeof input === 'string') return new URL(input, location.href)\n    if (input instanceof URL) return input\n    if (input instanceof Request) return new URL(input.url, location.href)\n    return null\n  } catch {\n    return null\n  }\n}\n\nexport const isMethodAllowed = (method: string) => {\n  const allowedMethods = ['GET', 'POST', 'PUT', 'DELETE']\n  return allowedMethods.includes(method.toUpperCase())\n}\n\n/**\n * Generate cache key from method, URL, and optional body\n */\nexport const generateCacheKey = (method: string, url: string, body?: string): string => {\n  return `${method.toUpperCase()}::${url}::${body || ''}`\n}\n\n/**\n * Serialize FormData to JSON with file metadata\n */\nexport const serializeFormData = (formData: FormData): string => {\n  const serialized: Record<string, unknown | StoredMedia> = {}\n  for (const [key, value] of formData.entries()) {\n    if (typeof value !== 'string') {\n      ;(serialized[key] as StoredMedia) = {\n        _file: true,\n        name: value.name || 'blob',\n        size: value.size,\n        type: value.type,\n      }\n    } else {\n      serialized[key] = value\n    }\n  }\n  return JSON.stringify(serialized)\n}\n\n/**\n * Calculate fake delay for file uploads based on file size\n * @param body - Serialized request body\n * @param uploadSpeed - Upload speed in bytes/second (default: 1MB/s)\n * @returns Delay in milliseconds\n */\nexport const calculateFileDelay = (body: string, uploadSpeed: number = 1048576): number => {\n  try {\n    const parsed = JSON.parse(body)\n    let totalSize = 0\n\n    // Type guard for StoredMedia\n    const isStoredMedia = (obj: unknown): obj is StoredMedia => {\n      return (\n        typeof obj === 'object' &&\n        obj !== null &&\n        '_file' in obj &&\n        obj._file === true &&\n        'size' in obj &&\n        typeof obj.size === 'number'\n      )\n    }\n\n    // Find all file metadata objects and sum their sizes\n    const findFiles = (obj: unknown): void => {\n      if (isStoredMedia(obj)) {\n        totalSize += obj.size\n      } else if (typeof obj === 'object' && obj !== null) {\n        Object.values(obj).forEach(findFiles)\n      }\n    }\n\n    findFiles(parsed)\n\n    if (totalSize > 0) {\n      // Calculate delay in milliseconds\n      return Math.round((totalSize / uploadSpeed) * 1000)\n    }\n  } catch {\n    // If parsing fails or no files found, no delay\n  }\n\n  return 0\n}\n\n/**\n * Shared helper: Serialize request body to string for caching\n * Supports FormData (with file metadata), Document (XML), and generic bodies\n */\nexport function serializeBody(body: any): string | undefined {\n  if (!body) return undefined\n  if (body instanceof FormData) return serializeFormData(body)\n  if (body instanceof Document) return new XMLSerializer().serializeToString(body)\n  if (typeof body === 'string') return body\n  // Handle Blob, ArrayBuffer, etc. by converting to string\n  return String(body)\n}\n\n/**\n * Check if request is eligible for caching/storage\n * Excludes media files, internal API calls, and unsupported methods\n */\nexport function isCacheable(url: URL | null, method: string): boolean {\n  return !!(url && !isMedia(url) && !isApi(url) && isMethodAllowed(method))\n}\n\nexport const originalFetch = window.fetch\nexport const originalXMLHttpRequest = window.XMLHttpRequest\n\nexport const isRecording = () => localStorage.getItem('magic-mock-recording') === 'true'\nexport const isMocking = () => localStorage.getItem('magic-mock-mocking') === 'true'\n","import { CacheRecord } from '../types'\nimport { calculateFileDelay, generateCacheKey } from '../utils'\nimport { Store } from './Store'\n\nexport class LocalStore implements Store {\n  private sizeLimit: number\n\n  constructor(sizeLimit: number = 50000) {\n    this.sizeLimit = sizeLimit\n  }\n\n  async get(\n    _: typeof window.fetch,\n    options: { url: string; method: string; body?: string },\n  ): Promise<Response> {\n    const { url, method, body } = options\n    const cacheKey = generateCacheKey(method, url, body)\n    const cacheResponse = localStorage.getItem(cacheKey)\n\n    if (!cacheResponse) {\n      throw new Error('Cache not found')\n    }\n\n    const cached = JSON.parse(cacheResponse) as CacheRecord\n\n    console.log('üîÑ Serving from cache:', method, url)\n    // Apply fake delay if file metadata detected\n    if (body) {\n      const delay = calculateFileDelay(body)\n      if (delay > 0) {\n        console.log(`‚è±Ô∏è Simulating upload delay: ${delay}ms`)\n        await new Promise((resolve) => setTimeout(resolve, delay))\n      }\n    }\n\n    // Return native Response instead of MSW HttpResponse\n    if (typeof cached.response === 'string') {\n      return new Response(cached.response, { status: cached.status, headers: cached.headers })\n    }\n    return new Response(JSON.stringify(cached.response), {\n      status: cached.status,\n      headers: cached.headers,\n    })\n  }\n\n  async set(\n    _: typeof window.fetch,\n    options: {\n      url: string\n      method: string\n      body?: string\n      data: string | Record<string, unknown>\n      response?: Response\n    },\n  ): Promise<void> {\n    const { url, method, body, data, response } = options\n\n    // Check body size against limit\n    if (this.sizeLimit > 0 && body) {\n      const bodySize = new Blob([body]).size\n      if (bodySize > this.sizeLimit) {\n        console.warn(`‚ö†Ô∏è Body too large to cache (${bodySize} bytes, limit: ${this.sizeLimit})`)\n        return\n      }\n    }\n\n    const status = response?.status\n    const headers = response ? response.headers : []\n\n    const cacheKey = generateCacheKey(method, url, body)\n    const record: CacheRecord = {\n      url,\n      method,\n      body,\n      response: data,\n      status,\n      headers: Object.fromEntries(headers.entries()),\n    }\n\n    localStorage.setItem(cacheKey, JSON.stringify(record))\n\n    console.log('‚úÖ Cached with Local Storage:', method, url)\n  }\n}\n","import { LocalStore } from './LocalStore'\nimport { RemoteStore } from './RemoteStore'\nimport { Store } from './Store'\n\ndeclare const __STANDALONE__: boolean\nexport const storage = __STANDALONE__ ? new LocalStore() : new RemoteStore()\n\nexport const createStore: () => Store = () => {\n  return __STANDALONE__ ? new LocalStore() : new RemoteStore()\n}\n","import { createStore } from '../store'\nimport { getURL, isCacheable, isMocking, isRecording, originalFetch, serializeBody } from '../utils'\n\nconst store = createStore()\n\nexport function overrideFetch() {\n  window.fetch = async function (...args: Parameters<typeof fetch>) {\n    const [input, init] = args\n    const method = init?.method ?? (input instanceof Request ? input.method : 'GET')\n\n    // Extract and serialize body if present\n    // Note: Document is not included here because fetch() doesn't support Document body in practice\n    // (only XHR does). While theoretically possible, it's never used in real-world fetch() calls.\n    let body: string | undefined\n    if (init?.body) {\n      body = serializeBody(init.body)\n    } else if (input instanceof Request && input.body) {\n      body = serializeBody(await input.clone().text())\n    }\n\n    // Check mock mode FIRST - try to serve from cache\n    const url = getURL(input)\n    const cachedResponse = await tryGetCachedResponse(url, method, body)\n    if (cachedResponse) {\n      return cachedResponse\n    }\n\n    // Make real request\n    const response = await originalFetch(...args)\n\n    // Record if needed\n    if (isRecording() && url && isCacheable(url, method) && response.ok) {\n      await tryStoreResponse(url, response, method, body)\n    }\n\n    return response\n  }\n}\n\n/**\n * Shared helper: Try to get cached response in mock mode\n * Returns Response if cache hit, null if cache miss or not eligible\n */\nasync function tryGetCachedResponse(\n  url: URL | null,\n  method: string,\n  body?: string,\n): Promise<Response | null> {\n  if (!isMocking() || !isCacheable(url, method)) {\n    return null\n  }\n\n  try {\n    return await store.get(originalFetch, {\n      url: url!.href,\n      method,\n      body,\n    })\n  } catch (e) {\n    console.log('‚ùå Cache miss:', method, url!.href)\n    return null\n  }\n}\n\nasync function tryStoreResponse(url: URL, response: Response, method: string, body?: string) {\n  const clone = response.clone()\n  const contentType = response.headers.get('content-type')\n\n  let data: string | Record<string, unknown>\n  if (contentType?.includes('application/json')) {\n    data = await clone.json()\n  } else {\n    data = await clone.text()\n  }\n\n  try {\n    await store.set(originalFetch, {\n      url: url.href,\n      method,\n      body,\n      data,\n      response,\n    })\n  } catch (e) {\n    console.error('Error while storing response', e)\n  }\n}\n","import { createStore } from '../store'\nimport {\n  getURL,\n  isCacheable,\n  isMocking,\n  isRecording,\n  originalFetch,\n  originalXMLHttpRequest,\n  serializeBody,\n} from '../utils'\nconst store = createStore()\n\nexport function overrideXHR() {\n  // Store original methods\n  const originalOpen = originalXMLHttpRequest.prototype.open\n  const originalSend = originalXMLHttpRequest.prototype.send\n\n  // Override open to capture method and URL\n  originalXMLHttpRequest.prototype.open = function (\n    method: string,\n    url: string | URL,\n    async: boolean = true,\n    user?: string | null,\n    password?: string | null,\n  ) {\n    // Store method and URL on the instance for later use in send\n    ;(this as any)._method = method\n    ;(this as any)._url = url\n    return originalOpen.call(this, method, url, async, user, password)\n  }\n\n  // Override send to intercept for both mocking and recording\n  originalXMLHttpRequest.prototype.send = function (\n    body?: Document | XMLHttpRequestBodyInit | null,\n  ) {\n    const xhr = this\n    const method = (xhr as any)._method\n    const url = (xhr as any)._url\n\n    // Serialize body using shared helper\n    const serializedBody = serializeBody(body)\n\n    // Check mock mode FIRST - try to serve from cache\n    const safeUrl = getURL(url)\n    if (isMocking() && isCacheable(safeUrl, method)) {\n      store\n        .get(originalFetch, {\n          url: safeUrl!.href,\n          method,\n          body: serializedBody,\n        })\n        .then(async (cachedResponse) => {\n          // Successfully got cached response - synthesize XHR response\n          console.log('üîÑ Serving XHR from cache:', method, safeUrl!.href)\n\n          const responseText = await cachedResponse.text()\n          const status = cachedResponse.status\n          const statusText = cachedResponse.statusText\n\n          // Manually set XHR properties to simulate response\n          Reflect.defineProperty(xhr, 'responseText', {\n            writable: true,\n            value: responseText,\n          })\n          Reflect.defineProperty(xhr, 'response', {\n            writable: true,\n            value: responseText,\n          })\n          Reflect.defineProperty(xhr, 'status', { writable: true, value: status })\n          Reflect.defineProperty(xhr, 'statusText', { writable: true, value: statusText })\n          Reflect.defineProperty(xhr, 'readyState', { writable: true, value: 4 })\n\n          const rsEvent = new Event('readystatechange')\n\n          xhr.dispatchEvent(rsEvent)\n\n          const loadEvent = new ProgressEvent('load', {\n            lengthComputable: true,\n            loaded: responseText.length,\n            total: responseText.length,\n          })\n          xhr.dispatchEvent(loadEvent)\n\n          // loadend\n          const loadEndEvent = new ProgressEvent('loadend', {\n            lengthComputable: true,\n            loaded: responseText.length,\n            total: responseText.length,\n          })\n          xhr.dispatchEvent(loadEndEvent)\n        })\n        .catch(() => {\n          console.log('‚ùå XHR Cache miss:', method, url)\n          // Cache miss - fall through to real XHR\n          sendRealXHR(xhr, method, url, serializedBody, body)\n        })\n\n      // Return immediately - we've handled it async\n      return\n    }\n\n    // Not mocking or not eligible for caching - send real request\n    sendRealXHR(xhr, method, url, serializedBody, body)\n  }\n\n  // Helper function to send real XHR and record if needed\n  function sendRealXHR(\n    xhr: XMLHttpRequest,\n    method: string,\n    url: string | URL,\n    serializedBody: string | undefined,\n    originalBody?: Document | XMLHttpRequestBodyInit | null,\n  ) {\n    const recordingHandler = function () {\n      // Record response when request is complete\n      const safeUrl = getURL(url)\n      console.log(xhr.readyState, isRecording(), isCacheable(safeUrl, method), xhr.status)\n      if (\n        xhr.readyState === 4 &&\n        isRecording() &&\n        isCacheable(safeUrl, method) &&\n        xhr.status >= 200 &&\n        xhr.status < 300\n      ) {\n        tryStoreXHRResponse(safeUrl!, xhr, method, serializedBody)\n      }\n    }\n\n    xhr.addEventListener('loadend', recordingHandler, { once: true })\n\n    return originalSend.call(xhr, originalBody)\n  }\n}\n\nasync function tryStoreXHRResponse(url: URL, xhr: XMLHttpRequest, method: string, body?: string) {\n  const contentType = xhr.getResponseHeader('content-type')\n\n  let data: string | Record<string, unknown>\n  if (contentType?.includes('application/json')) {\n    try {\n      data = JSON.parse(xhr.responseText)\n    } catch {\n      data = xhr.responseText\n    }\n  } else {\n    data = xhr.responseText\n  }\n\n  const headers = new Headers()\n  // Copy response headers\n  const responseHeaders = xhr.getAllResponseHeaders()\n  if (responseHeaders) {\n    responseHeaders.split('\\r\\n').forEach((header) => {\n      const [key, value] = header.split(': ')\n      if (key && value) {\n        headers.set(key, value)\n      }\n    })\n  }\n\n  // Create a mock Response object for storage compatibility\n  const mockResponse = new Response(xhr.responseText, {\n    status: xhr.status,\n    statusText: xhr.statusText,\n    headers,\n  })\n  console.log({\n    url: url.href,\n    method,\n    body,\n    data,\n    response: mockResponse,\n  })\n  try {\n    await store.set(originalFetch, {\n      url: url.href,\n      method,\n      body,\n      data,\n      response: mockResponse,\n    })\n  } catch (e) {\n    console.error('Error while storing XHR response', e)\n  }\n}\n","import { isMocking, isRecording } from '../utils'\n\nexport function createButtons() {\n  const container = document.createElement('div')\n  container.style.cssText =\n    'position: fixed; top: 10px; right: 10px; z-index: 99999; display: flex; gap: 10px;'\n\n  const recordBtn = document.createElement('button')\n  recordBtn.textContent = isRecording() ? '‚èπ Recording...' : '‚è∫ Record'\n  recordBtn.style.cssText = `padding: 10px 15px; background: ${\n    isRecording() ? '#ff0000' : '#ff4444'\n  }; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2);`\n\n  const mockBtn = document.createElement('button')\n  mockBtn.textContent = isMocking() ? '‚úì Mocking' : 'üîÑ Mock'\n  mockBtn.style.cssText = `padding: 10px 15px; background: ${\n    isMocking() ? '#0000ff' : '#4444ff'\n  }; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2);`\n\n  recordBtn.onclick = () => {\n    const newIsRecording = !isRecording()\n    localStorage.setItem('magic-mock-recording', newIsRecording.toString())\n    recordBtn.style.background = isRecording() ? '#ff0000' : '#ff4444'\n    recordBtn.textContent = isRecording() ? '‚èπ Recording...' : '‚è∫ Record'\n    console.log('Recording:', isRecording())\n  }\n\n  mockBtn.onclick = () => {\n    const newIsMocking = !isMocking()\n    localStorage.setItem('magic-mock-mocking', newIsMocking.toString())\n    mockBtn.style.background = newIsMocking ? '#0000ff' : '#4444ff'\n    mockBtn.textContent = newIsMocking ? '‚úì Mocking' : 'üîÑ Mock'\n    console.log('Mocking:', newIsMocking)\n  }\n\n  container.appendChild(recordBtn)\n  container.appendChild(mockBtn)\n  document.body.appendChild(container)\n}\n","import { overrideFetch } from './override/fetch'\nimport { overrideXHR } from './override/xhr'\nimport { createButtons } from './ui/hud'\n\ndeclare const __STANDALONE__: boolean\n\nexport function initMagicMock() {\n  overrideFetch()\n  overrideXHR()\n\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', createButtons)\n  } else {\n    createButtons()\n  }\n}\n\nif (!__STANDALONE__) {\n  initMagicMock()\n}\n"],"mappings":"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"}